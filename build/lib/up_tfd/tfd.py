import os
import sys
import unified_planning as up
import re
from fractions import Fraction
from typing import IO, Any, Callable, Optional, List, Tuple, Union, cast

from unified_planning.model import ProblemKind
from unified_planning.engines import OptimalityGuarantee, PlanGenerationResultStatus
from unified_planning.engines import PDDLPlanner, Credits
from unified_planning.exceptions import UPException


credits = Credits('Temporal Fast Downward',
                  'Davide Lusuardi',
                  'davide.lusuardi@studenti.unitn.it',
                  'http://gki.informatik.uni-freiburg.de/tools/tfd/',
                  'GPLv3',
                  'TFD is a temporal planning system that is based on Fast Downward and uses an adaptation of the context-enhanced additive heuristic.',
                  'TFD is a temporal planning system that is based on Fast Downward and uses an adaptation of the context-enhanced additive heuristic.')


class tfdPDDLPlanner(PDDLPlanner):

    def __init__(self):
        super().__init__()

    @property
    def name(self) -> str:
        return 'Temporal Fast Downward'

    @staticmethod
    def get_credits(**kwargs) -> Optional['Credits']:
        return credits

    def _plan_from_file(
        self,
        problem: "up.model.Problem",
        plan_filename: str,
        get_item_named: Callable[
            [str],
            Union[
                "up.model.Type",
                "up.model.Action",
                "up.model.Fluent",
                "up.model.Object",
                "up.model.Parameter",
                "up.model.Variable",
            ],
        ],
    ) -> "up.plans.Plan":
        """
        Takes a problem, a filename and a map of renaming and returns the plan parsed from the file.

        :param problem: The up.model.problem.Problem instance for which the plan is generated.
        :param plan_filename: The path of the file in which the plan is written.
        :param get_item_named: A function that takes a name and returns the original up.model element instance
            linked to that renaming.
        :return: The up.plans.Plan corresponding to the parsed plan from the file
        """
        actions: List = []
        with open(plan_filename) as plan:
            is_tt = False
            for line in plan.readlines():
                if re.match(r"^\s*(;.*)?$", line):
                    continue
                line = line.lower()
                s_ai = re.match(r"^\s*\(\s*([\w?-]+)((\s+[\w?-]+)*)\s*\)\s*$", line)
                t_ai = re.match(
                    r"^\s*(\d+\.\d+):\s*\(\s*([\w-]+)([\s\w-]*)\)\s*\[(\d+\.\d+)\]\s*$",
                    # r"^\s*(\d+)\s*:\s*\(\s*([\w?-]+)((\s+[\w?-]+)*)\s*\)\s*(\[\s*(\d+)\s*\])?\s*$",
                    line,
                )
                if s_ai:
                    assert is_tt == False
                    name = s_ai.group(1)
                    params_name = s_ai.group(2).split()
                elif t_ai:
                    is_tt = True
                    start = Fraction(t_ai.group(1))
                    name = t_ai.group(2)
                    params_name = [arg.strip() for arg in t_ai.group(3).split()]
                    dur = None
                    if t_ai.group(4) is not None:
                        dur = Fraction(t_ai.group(4))
                else:
                    raise UPException(
                        "Error parsing plan generated by " + self.__class__.__name__
                    )

                action = get_item_named(name)
                assert isinstance(action, up.model.Action), "Wrong plan or renaming."
                parameters = []
                for p in params_name:
                    obj = get_item_named(p)
                    assert isinstance(obj, up.model.Object), "Wrong plan or renaming."
                    parameters.append(problem.env.expression_manager.ObjectExp(obj))
                act_instance = up.plans.ActionInstance(action, tuple(parameters))
                if is_tt:
                    actions.append((start, act_instance, dur))
                else:
                    actions.append(act_instance)
        if is_tt:
            return up.plans.TimeTriggeredPlan(actions)
        else:
            return up.plans.SequentialPlan(actions)


    def _get_cmd(self, domain_filename: str,
                 problem_filename: str, plan_filename: str) -> List[str]:
        # tfd_executable = os.path.join(os.environ.get('TFD_PREFIX'), 'downward', 'plan')
        # os.chdir(os.path.dirname(tfd_executable))
        # cmd = ['/bin/bash', tfd_executable, domain_filename, problem_filename, plan_filename]
        # sys.path.append(os.path.dirname(tfd_executable))
        # cmd = ['/usr/bin/python2', tfd_executable, "y+Y+e+r+O+1+C+1+b", domain_filename, problem_filename, plan_filename]
        executable = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'plan.py')
        cmd = [sys.executable, executable, domain_filename, problem_filename, plan_filename]
        return cmd

    # TODO
    def _result_status(
        self,
        problem: "up.model.Problem",
        plan: Optional["up.plans.Plan"],
        retval: int = None, # Default value for legacy support
        #log_messages: Optional[List[LogMessage]] = None,
        log_messages = None,
        ) -> "up.engines.results.PlanGenerationResultStatus":

        # https://www.fast-downward.org/ExitCodes
        if retval is None: # legacy support
            if plan is None:
                return PlanGenerationResultStatus.UNSOLVABLE_INCOMPLETELY
            else:
                return PlanGenerationResultStatus.SOLVED_SATISFICING
        if retval in (0, 1, 2, 3):
            if plan is None:
                # Should not be possible after portfolios have been fixed
                return PlanGenerationResultStatus.UNSOLVABLE_INCOMPLETELY
            else:
                return PlanGenerationResultStatus.SOLVED_SATISFICING
        if retval in (10, 11):
            return PlanGenerationResultStatus.UNSOLVABLE_PROVEN
        if retval == 12:
            return PlanGenerationResultStatus.UNSOLVABLE_INCOMPLETELY
        else:
            return up.engines.results.PlanGenerationResultStatus.INTERNAL_ERROR

    # TODO
    @staticmethod
    def satisfies(optimality_guarantee: 'OptimalityGuarantee') -> bool:
        if optimality_guarantee == OptimalityGuarantee.SATISFICING:
            return True
        return False

    # TODO: these are the tamer supports
    @staticmethod
    def supported_kind() -> 'ProblemKind':
        supported_kind = ProblemKind()
        supported_kind.set_problem_class('ACTION_BASED') # type: ignore
        supported_kind.set_time('CONTINUOUS_TIME') # type: ignore
        supported_kind.set_time('INTERMEDIATE_CONDITIONS_AND_EFFECTS') # type: ignore
        supported_kind.set_time('TIMED_EFFECT') # type: ignore
        supported_kind.set_time('TIMED_GOALS') # type: ignore
        supported_kind.set_time('DURATION_INEQUALITIES') # type: ignore
        supported_kind.set_expression_duration('STATIC_FLUENTS_IN_DURATION') # type: ignore
        supported_kind.set_expression_duration('FLUENTS_IN_DURATION') # type: ignore
        supported_kind.set_numbers('DISCRETE_NUMBERS') # type: ignore
        supported_kind.set_numbers('CONTINUOUS_NUMBERS') # type: ignore
        supported_kind.set_problem_type("SIMPLE_NUMERIC_PLANNING") # type: ignore
        supported_kind.set_problem_type("GENERAL_NUMERIC_PLANNING") # type: ignore
        supported_kind.set_typing('FLAT_TYPING') # type: ignore
        supported_kind.set_conditions_kind('NEGATIVE_CONDITIONS') # type: ignore
        supported_kind.set_conditions_kind('DISJUNCTIVE_CONDITIONS') # type: ignore
        supported_kind.set_conditions_kind('EQUALITY') # type: ignore
        supported_kind.set_fluents_type('NUMERIC_FLUENTS') # type: ignore
        supported_kind.set_fluents_type('OBJECT_FLUENTS') # type: ignore
        supported_kind.set_simulated_entities('SIMULATED_EFFECTS') # type: ignore
        return supported_kind

    @staticmethod
    def supports(problem_kind: 'ProblemKind') -> bool:
        return problem_kind <= tfdPDDLPlanner.supported_kind()

